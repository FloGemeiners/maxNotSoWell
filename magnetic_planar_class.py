"""
Collection of classes allowing for the setup of 2D magnetoquasitatic Maxwell problems. For now, sources of the magnetic
field are limited to being electric currents.

The Magnetic2D class is to be understood as the magnetic pendant of the electrostatic case, while the Magnetic2DHcurl
class also incorporates Nédélec elements for the direct calculation of the magnetic vector potential. In the latter class
currents are to be understood as in-plane, while the first case covers the simplest scenario in which the currents are
purely perpendicular to it.

Usage:
    from magnetic_planar_class import *

Author:
    Florian Meiners - November 25, 2025; Last updated January 19, 2026
"""

from dataclasses import dataclass
from typing import Callable, Tuple, Optional
import numpy as np
from finite_element_classes import NedelecFirstKindTriP1
from electrostatics_class import TriangleQuadrature

try:
    import scipy.sparse as sp
    import scipy.sparse.linalg as spla
    HAS_SCIPY = True
except Exception:
    HAS_SCIPY = False

# Definition of a scalar and vector field.
ScalarField = Callable[[float, float], float]
VectorField2D = Callable[[float, float], Tuple[float, float]]

@dataclass
class MaterialMu:
    """
    Class to specify the distribution of permeability across the spatial domain.

    Attributes:
    -----------
    mu: Callable
        The value of the permeability at the given point.

    Methods:
    -----------
    at(self, x:float, y:float)
        Returns the permeability at the specified point.
    """
    mu: ScalarField
    def at(self, x: float, y: float) -> float:
        return self.mu(x, y)

@dataclass
class CurrentDensity:
    """
    Class to specify the distribution of current density across the spatial domain.

    Attributes:
    -----------
    j_vec: Callable
        The value of the current density in z direction at the given point.
        Note that the currents are necessarily perpendicular to the plane.

    Methods:
    ----------
    at(self, x:float, y:float)
        Returns the current density at the specified point.
    """
    j_vec: ScalarField
    def at(self, x: float, y: float) -> float:
        return self.j_vec(x, y)

@dataclass
class DirichletBCMagnetic:
    """
    Class to specify the Dirichlet boundary conditions for the magnetic field.

    Attributes:
    -----------
    nodes : np.ndarray
        The nodes to specify the position of the boundary.
    value : ScalarField
        See above.

    Methods:
    -----------
    values(self, XY: np.ndarray)
        Returns the values at the boundary.
    """
    nodes: np.ndarray
    value: ScalarField
    def values(self, XY: np.ndarray) -> np.ndarray:
        return np.array([self.value(x, y) for x, y in XY[self.nodes]], dtype=float)

@dataclass
class DirichletBCMagneticEdge:
    """
    Class to specify Dirichlet boundary conditions for the H(curl) magnetic formulation with Nédélec edge elements.

    Notes (generated by ChatGPT):
    -----------------------------
    For lowest-order Nédélec elements, each DOF on edge e represents
        dof_e(A) = ∫_e A · t̂ ds
    where t̂ is the unit tangent in the *global* edge orientation.

    We approximate this integral by midpoint rule:
        dof_e ≈ g(x_mid, y_mid) * |e|

    Attributes:
    -----------
    edges : np.ndarray
        1D array of global edge indices where the BC is applied. Each edge index refers to a row in mesh.edges (node pair).
    value : Optional[ScalarField]
        Function g(x, y) giving the prescribed *tangential* component
        A_t(x, y) = A(x, y) · t̂ in the direction of the global edge orientation. If None, homogeneous BC A_t = 0 is used.
    """
    edges: np.ndarray
    value: Optional[ScalarField] = None

    def values(self, nodes: np.ndarray, edges: np.ndarray) -> np.ndarray:
        """
        Compute the edge-DOF values implied by this BC.

        Parameters:
        -----------
        nodes : (n_nodes, 2) array
            Node coordinates (mesh.nodes).
        edges : (n_edges, 2) array
            Global edge list (mesh.edges). Each row is (n0, n1) with the chosen global orientation.

        Returns:
        -----------
        vals : (len(self.edges),) array
            Prescribed values for the edge DOFs, in the same order as self.edges.
        """
        vals = []
        for e_idx in self.edges:
            e_idx = int(e_idx)
            n0, n1 = edges[e_idx]
            x0, y0 = nodes[n0]
            x1, y1 = nodes[n1]

            # Global oriented edge vector (from node n0 to n1)
            t_vec = np.array([x1 - x0, y1 - y0], dtype=float)
            length = np.linalg.norm(t_vec)

            # Degenerate edge safety
            if length == 0.0:
                vals.append(0.0)
                continue

            # Midpoint of the edge
            xm = 0.5 * (x0 + x1)
            ym = 0.5 * (y0 + y1)

            if self.value is None:
                # Homogeneous tangential BC: A_t = 0 ⇒ DOF = 0
                vals.append(0.0)
            else:
                # Prescribed tangential component A_t(xm,ym)
                At = float(self.value(xm, ym))
                # Approximate integral ∫_e A·t ds ≈ A_t(x_mid) * |e|
                vals.append(At * length)

        return np.array(vals, dtype=float)

@dataclass
class NeumannBCMagneticEdge:
    """
    Class to specify Neumann boundary conditions for the H(curl) magnetic formulation with Nédélec edge elements.

    Attributes:
    -----------
    edges : np.ndarray
        1D array of global edge indices where the BC is applied. Each edge index refers to a row in mesh.edges (node pair).
    edge_tris: np.ndarray
        triangles with an edge that is part of the boundary
        (every edge on the boundary has its triangle in this collection, meaning that triangles are listed twice if they
        are at the corner of the domain)
    value : Optional[VectorField2D]
        callable giving the prescribed magnetic field tangent to the boundary
    """
    edges: np.ndarray
    value: Optional[VectorField2D] = None

    def values(self, nodes: np.ndarray, edges: np.ndarray) -> np.ndarray:
        """
        Compute the edge-DOF values implied by this BC.

        Parameters:
        -----------
        nodes : (n_nodes, 2) array
            Node coordinates (mesh.nodes).
        edges : (n_edges, 2) array
            Global edge list (mesh.edges). Each row is (n0, n1) with the chosen global orientation.

        Returns:
        -----------
        vals : (len(self.edges),) array
            Prescribed values for the edge DOFs, in the same order as self.edges.
        """
        vals = []
        for e_idx in self.edges:
            e_idx = int(e_idx)
            n0, n1 = edges[e_idx]
            x0, y0 = nodes[n0]
            x1, y1 = nodes[n1]

            # Global oriented edge vector (from node n0 to n1)
            t_vec = np.array([x1 - x0, y1 - y0], dtype=float)
            length = np.linalg.norm(t_vec)

            # Degenerate edge safety
            if length == 0.0:
                vals.append((0.0, 0.0))
                continue

            # Midpoint of the edge
            xm = 0.5 * (x0 + x1)
            ym = 0.5 * (y0 + y1)

            if self.value is None:
                vals.append((0.0, 0.0))
            else:
                # Prescribed tangential component H_t(xm,ym), assumed constant along this part of the boundary
                Htx, Hty = self.value(xm, ym)
                vals.append((Htx, Hty))

        return np.array(vals, dtype=float)

class Magnetic2D:
    """
    Class to define a magnetic boundary value problem in two dimensions. The degree of freedom in this case is the z
    component of the magnetic vector potential.

    Attributes:
    -----------
        nodes: np.ndarray
            array of nodes to calculate the potential (and magnetic field) for
        tris: np.ndarray
            array of tris to use for the FEM analyis
        material: MaterialMu
            distribution of permeability across the spatial domain
        source: CurrentDensity
            distribution of current density across the spatial domain
        N: int
            number of nodes
        A_vec: np.ndarray
            magnetic vector potential (z component) at the nodes
        _assembled: boolean
            specifying whether the problem is completely assembled
        _K: np.ndarray
            stiffness matrix for specifying the FEM problem
        _f: np.ndarray
            load matrix for specifying the FEM problem

        In case boundary conditions are applied to the problem:
        _fixed_idx: np.ndarray (optional)
            indices specifying fixed nodes
        _free_idx: np.ndarray (optional)
            indices specifying free nodes
        _fixed_vals: np.ndarray (optional)
            specified fixed values
        _K_reduced: np.ndarray (optional)
            reduced _K-matrix
        _f_reduced: np.ndarray (optional)
            reduced _f-matrix
        _use_reduced: boolean (optional)
            tells the solver whether to use the reduced matrices for calculation

        Methods:
        -----------
        _triangle_area_and_grads(p: np.ndarray)
            static method to return the areas and gradients at the specified triangle
        assemble(self)
            Assembles and returns the FEM problem
        apply_dirichlet(self, bcs)
            Applies the dirichlet boundary conditions to the magnetic problem.
        solve(self)
            Solves the FEM problem.
        magnetic_field(self)
            Computes the magnetic field at the nodes.
    """
    def __init__(self, nodes: np.ndarray, tris:np.ndarray,
                 material: MaterialMu, source: Optional[CurrentDensity] = None):
        """
        Constructor.

        Parameters:
        -----------
        nodes: np.ndarray
            array of nodes to solve the problem for
        tris: np.ndarray
            array of triangles to use for the FEM analyis
        material: MaterialMu
            distribution of permeability across the spatial domain
        source: CurrentDensity, optional
            charge density across the spatial domain (default = None)
        """
        self.nodes = nodes
        self.tris = tris
        self.material = material
        self.source = source or CurrentDensity(lambda x, y: 0.0)
        self.N = nodes.shape[0]
        self.A_vec = np.zeros(self.N)
        self._assembled = False
        self._K = None
        self._f = None

    @staticmethod
    def _triangle_area_and_grads(p: np.ndarray) -> Tuple[float, np.ndarray]:
        """
        Method to return the areas and gradients of the specified triangle. This functions implicitly works with linear
        shape functions.

        Parameters:
        -----------
        p: np.ndarray
            array of points characterizing the triangle

        Returns:
        -----------
        A: np.ndarray
            areas of the triangle
        grads: np.ndarray
            gradients at the vertices of the triangle
        """
        x0, y0 = p[0]
        x1, y1 = p[1]
        x2, y2 = p[2]
        area2 = np.abs((x1 - x0) * (y2 - y0) - (x2 - x0) * (y1 - y0))
        A = abs(area2) * 0.5
        b = np.array([y1 - y2, y2 - y0, y0 - y1], dtype=float)
        c = np.array([x2 - x1, x0 - x2, x1 - x0], dtype=float)
        grads = np.column_stack([b, c]) / (2.0 * A)
        return A, grads

    def assemble(self):
        """
        Assembles the magnetic FEM problem by setting the stiffness and load matrices.

        Parameters:
        -----------
        self: Magnetic2D

        Returns:
        -----------
        Nothing

        Sets:
        -----------
        self._assembled, self._K and self._f
        """
        N = self.N
        if HAS_SCIPY:
            rows, cols, data = [], [], []
            f = np.zeros(N, dtype=float)
            for tri in self.tris:
                p = self.nodes[tri]
                A, grads = self._triangle_area_and_grads(p)
                xc, yc = p.mean(axis=0)
                mu = self.material.at(xc, yc)
                Ke = mu * A * (grads @ grads.T)
                j_c = self.source.at(xc, yc)
                fe = np.full(3, j_c * A /3.0, dtype=float)
                for a in range(3):
                    ia = int(tri[a])
                    for a in range(3):
                        ia = int(tri[a])
                        f[ia] += fe[a]
                        for b in range(3):
                            ib = int(tri[b])
                            rows.append(ia)
                            cols.append(ib)
                            data.append(Ke[a, b])
            K = sp.coo_matrix((data, (rows, cols)), shape=(N, N)).tocsr()
        else:
            K = np.zeros((N, N), dtype=float)
            f = np.zeros(N, dtype=float)
            for tri in self.tris:
                p = self.nodes[tri]
                A, grads = self._triangle_area_and_grads(p)
                xc, yc = p.mean(axis=0)
                mu = self.material.at(xc, yc)
                Ke = mu * A * (grads @ grads.T)
                j_c = self.source.at(xc, yc)
                fe = np.full(3, j_c * A / 3.0, dtype=float)
                for a in range(3):
                    ia = int(tri[a])
                    f[ia] += fe[a]
                    for b in range(3):
                        ib = int(tri[b])
                        K[ia, ib] += Ke[a, b]
        self._K, self._f = K, f
        self._assembled = True

    def apply_dirichlet(self, bcs):
        """
        Method for applying the Dirichlet boundary conditions (potential at boundary).
        When these boundary conditions are applied, the object receives additional attributes.

        Parameters:
        -----------
        self: Magnetic2D
        bcs: DirichletBCMagnetic

        Returns:
        -----------
        Nothing

        Sets:
        -----------
        self._K and self._f, as well as the optional
        _free_idx, _fixed_idx, _fixed_vals, _K_reduced, _f_reduced, _use_reduced
        """
        if not self._assembled:
            self.assemble()

        fixed = {}
        for bc in bcs:
            vals = bc.values(self.nodes)
            for n, v in zip(bc.nodes, vals):
                fixed[int(n)] = float(v)

        self._fixed_idx = np.array(sorted(fixed.keys()), dtype=int)
        self._fixed_vals = np.array([fixed[i] for i in self._fixed_idx], dtype=float)

        all_idx = np.arange(self.N, dtype=int)
        self._free_idx = np.setdiff1d(all_idx, self._fixed_idx, assume_unique=True)

        K = self._K
        f = self._f
        I = self._fixed_idx
        F = self._free_idx
        g = self._fixed_vals

        if HAS_SCIPY and sp.issparse(K):
            K = K.tocsr()
            K_ff = K[F, :][:, F]
            K_fc = K[F, :][:, I]
            f_f = f[F] - K_fc @ g
        else:
            K_ff = K[np.ix_(F, F)]
            K_fc = K[np.ix_(F, I)]
            f_f = f[F] - K_fc @ g

        self._K_reduced = K_ff
        self._f_reduced = f_f
        self._use_reduced = True

    def solve(self) -> np.ndarray:
        """
        Method for solving the magnetic FEM problem and returning the z component of the vector potential.

        Parameters:
        -----------
        self: Magnetic2D

        Returns:
        -----------
        self.A_vec
            the potential at the nodes

        Sets:
        -----------
        self.A_vec
        """
        import numpy as np
        try:
            import scipy.sparse as sp
            import scipy.sparse.linalg as spla
            HAS_SCIPY = True
        except Exception:
            HAS_SCIPY = False

        if not self._assembled:
            self.assemble()

        if getattr(self, "_use_reduced", False):
            K = self._K_reduced
            f = self._f_reduced
            if HAS_SCIPY and sp.issparse(K):
                u_free = spla.spsolve(K, f)
            else:
                u_free = np.linalg.solve(K, f)

            A_vec_z = np.empty(self.N, dtype=float)
            A_vec_z[self._fixed_idx] = self._fixed_vals
            A_vec_z[self._free_idx] = u_free
            self.A_vec = A_vec_z
            return self.A_vec

        K_full, f_full = self._K, self._f
        if HAS_SCIPY and sp.issparse(K_full):
            self.A_vec = spla.spsolve(K_full, f_full)
        else:
            self.A_vec = np.linalg.solve(K_full, f_full)
        return self.A_vec

    def magnetic_field(self) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        """
        Method for calculating the magnetic field.

        Parameters:
        -----------
        self: Magnetic2D

        Returns:
        -----------
        Bx_nodes
            x component of the magnetic field
        By_nodes
            y component of the magnetic field
        centers
            coordinates of the nodes
        """
        if self.A_vec is None or self.A_vec.size == 0:
            raise RuntimeError("Call solve() first.")
        N = self.N
        Bx_acc = np.zeros(N)
        By_acc = np.zeros(N)
        count = np.zeros(N)

        for tri in self.tris:
            p = self.nodes[tri]
            A, grads = self._triangle_area_and_grads(p)
            A_loc = self.A_vec[tri]
            test = grads
            B_elem = (A_loc[:, None] * grads).sum(axis=0)
            for n in tri:
                Bx_acc[n] += B_elem[1]
                By_acc[n] += -B_elem[0]
                count[n] += 1.0

        Bx_nodes = Bx_acc / np.maximum(count, 1.0)
        By_nodes = By_acc / np.maximum(count, 1.0)
        centers = self.nodes
        return Bx_nodes, By_nodes, centers

VectorSource = Callable[[float, float], Tuple[float, float]]

class Magnetic2DHcurl:
    """
    Similar to the Magnetic2D class, but with a 2D magneto(quasi)static H(curl) formulation with Nédélec elements. In
    that vein, the currents are no longer assumed to only be out of plane, for this more complex formulation to still be
    interesting.

    Still, though, the unknown is A(x,y) ∈ H(curl), discretized with lowest-order Nédélec elements and there is one DOF
    per edge. The right hand side (for now) is still a scalar current density J_z(x,y), entering as ∫ J_z curl(v) dx.
    The bilinear form is ∫ μ^{-1} curl(A) curl(v) dx + α ∫ A·v dx, where the latter is a small gauge term.

    Note: by neglecting the boundary term appearing due to the integration by parts (see the readme), one implicitly
    applies Neumann boundary conditions (all zero) by default, if no other Neumann-type boundary conditions are enforced.

    Attributes:
    -----------
        mesh: Mesh2DRect
            The mesh across the spatial domain in which to solve the boundary value problem.
        nodes: np.ndarray
            array of nodes to calculate the potential (and magnetic field) for
        tris: np.ndarray
            array of tris to use for the FEM analyis
        material: MaterialMu
            distribution of permeability across the spatial domain
        source: CurrentDensity
            distribution of current density across the spatial domain
        alpha: float
            gauge value (see LHS above)
        N: int
            number of edges
        fin_elem: NedelecFirstKindTriP1
            Instance of the reference finite element that the method is based on
        A_edge: np.ndarray
            magnetic vector potential at the edges
        _assembled: boolean
            specifying whether the problem is completely assembled
        _K: np.ndarray
            stiffness matrix for specifying the FEM problem
        _f: np.ndarray
            load matrix for specifying the FEM problem

        In case boundary conditions are applied to the problem:
        _fixed_idx: np.ndarray (optional)
            indices specifying fixed DOFs
        _free_idx: np.ndarray (optional)
            indices specifying free DOFs
        _fixed_vals: np.ndarray (optional)
            specified fixed values
        _K_reduced: np.ndarray (optional)
            reduced _K-matrix
        _f_reduced: np.ndarray (optional)
            reduced _f-matrix
        _use_reduced: boolean (optional)
            tells the solver whether to use the reduced matrices for calculation

        Methods:
        -----------
        assemble(self, quad=TriangleQuadrature())
            Assembles and returns the FEM problem based on the given quadrature rule
        def _local_matrices(self, cell_vertices: np.ndarray, quad_pts: np.ndarray, quad_w: np.ndarray)
            static method to return the areas and gradients at the triangle spedified by the barycenter and weight
        apply_dirichlet(self, bcs: list[DirichletBCMagneticEdge])
            Applies the given edge-based Dirichlet boundary conditions to the magnetic problem.
        apply_neumann(self, bcs):
            Applies the given Neumann boundary conditions to the magnetic problem.
        solve(self)
            Solves the 2D magnetoquasistatic FEM problem based on Nédélec elements.
        magnetic_field(self, quad=TriangleQuadrature())
            Computes the magnetic field at the nodes based on the specified quadrature rule.
    """
    def __init__(self, mesh: np.ndarray, material: MaterialMu, source: Optional[CurrentDensity] = None, alpha=1e-6,
                 vector_source: Optional[VectorSource] = None, fin_elem=None):
        """
        Constructor.

        Parameters:
        -----------

        mesh: Mesh2DRect
            mesh across the spatial domain
        nodes: np.ndarray
            array of nodes to solve the problem for
        tris: np.ndarray
            array of triangles to use for the FEM analysis
        material: MaterialMu
            distribution of permittivity across the spatial domain
        source: CurrentDensity, optional
            current density into and out of across the spatial domain (default = None)
        vector_source: VectorSource, optional
            in-plane current density across the spatial domain (default = None)
        """
        self.mesh = mesh
        self.nodes = mesh.nodes
        self.tris = mesh.tris
        self.material = material
        self.source = source or CurrentDensity(lambda x, y: 0.0)
        self.vector_source = vector_source
        # this is so that the Magnetic2DHcurl class knows what type of element it is using:
        self.fin_elem = fin_elem if fin_elem is not None else NedelecFirstKindTriP1()
        self.N = self.mesh.edges.shape[0]
        self.alpha = alpha
        self.A_edge = np.zeros(self.N, dtype=float)
        self._assembled = False
        self._K = None
        self._f = None

    def assemble(self, quad=TriangleQuadrature()):
        """
        Assembles the magnetic FEM problem by setting the stiffness and load matrices.

        Parameters:
        -----------
        self: Magnetic2D

        Returns:
        -----------
        Nothing

        Sets:
        -----------
        self._assembled, self._K and self._f
        """
        N = self.N
        quad_pts, quad_w = quad.points, quad.weights

        if HAS_SCIPY:
            rows, cols, data = [], [], []
            f = np.zeros(N, dtype=float)

            for cell_id, tri in enumerate(self.mesh.tris):
                cell_vertices = self.mesh.nodes[tri]

                # set element matrices/vectors in the local edge basis
                Ke_local, fe_local = self._local_matrices(cell_vertices, quad_pts, quad_w)

                # map local edge DOFs to global DOFs with orientation
                edge_dofs = self.mesh.tri_edges[cell_id]
                edge_signs = self.mesh.tri_edge_signs[cell_id]

                for a_local, I in enumerate(edge_dofs):
                    s_a = edge_signs[a_local]
                    f[I] += s_a * fe_local[a_local]
                    for b_local, J in enumerate(edge_dofs):
                        s_b = edge_signs[b_local]
                        rows.append(I)
                        cols.append(J)
                        data.append(s_a * s_b * Ke_local[a_local, b_local])

            K = sp.coo_matrix((data, (rows, cols)), shape=(N, N)).tocsr()

        else:
            K = np.zeros((N, N), dtype=float)
            f = np.zeros(N, dtype=float)

            for cell_id, tri in enumerate(self.mesh.tris):
                cell_vertices = self.mesh.nodes[tri]
                Ke_local, fe_local = self._local_matrices(cell_vertices, quad_pts, quad_w)

                edge_dofs = self.mesh.tri_edges[cell_id]
                edge_signs = self.mesh.tri_edge_signs[cell_id]

                for a_local, I in enumerate(edge_dofs):
                    s_a = edge_signs[a_local]
                    f[I] += s_a * fe_local[a_local]
                    for b_local, J in enumerate(edge_dofs):
                        s_b = edge_signs[b_local]
                        K[I, J] += s_a * s_b * Ke_local[a_local, b_local]

        self._K, self._f = K, f
        self._assembled = True

    def _local_matrices(self, cell_vertices: np.ndarray, quad_pts: np.ndarray,
                        quad_w: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
        """
        Computes the local stiffness matrix Ke and load vector fe for one triangle in H(curl) formulation using
        Nédélec P1 (see the problem formulation above).

        Parameters:
        -----------
        cell_vertices: np.ndarray
            array of cell vertices
        quad_pts: np.ndarray
            array of quadrature points
        quad_w: np.ndarray
            array of quadrature weights

        Returns:
        -----------
        K: np.ndarray
            local stiffness matrix
        f: np.ndarray
            local load vector
        """
        fin_elem = self.fin_elem
        n_dofs = fin_elem.num_local_dofs()
        Ke = np.zeros((n_dofs, n_dofs), dtype=float)
        fe_local = np.zeros(n_dofs, dtype=float)

        # geometry
        J, detJ, invJT, x0 = fin_elem._compute_affine_jacobian(cell_vertices)
        w_phys = quad_w * abs(detJ)

        # basis functions and curls on the physical cell
        N_vals = fin_elem.evaluate_basis(cell_vertices, quad_pts)
        curls = fin_elem.evaluate_curl(cell_vertices, quad_pts)

        for q in range(quad_pts.shape[0]):
            xi_eta = quad_pts[q]
            x_q = x0 + J @ xi_eta  # physical quadrature point
            wq = w_phys[q]

            mu = self.material.at(x_q[0], x_q[1])
            mu_inv = 1.0 / mu
            # Jz = self.source.at(x_q[0], x_q[1])

            curl_q = curls[q]
            Nq = N_vals[q]

            # stiffness contribution of individual elements
            for a in range(n_dofs):
                for b in range(n_dofs):
                    curl_term = mu_inv * curl_q[a] * curl_q[b]
                    mass_term = self.alpha * np.dot(Nq[a], Nq[b])
                    Ke[a, b] += (curl_term + mass_term) * wq

            # load contribution of individual elements
            # scalar J_z source
            if self.source is not None:
                Jz = self.source.at(x_q[0], x_q[1])
                for a in range(n_dofs):
                    fe_local[a] += Jz * curl_q[a] * wq

            # NEW: in-plane J(x,y)=(Jx,Jy) source
            if self.vector_source is not None:
                Jx, Jy = self.vector_source(x_q[0], x_q[1])
                J_vec = np.array([Jx, Jy], dtype=float)
                for a in range(n_dofs):
                    fe_local[a] += np.dot(J_vec, Nq[a]) * wq

        return Ke, fe_local

    def apply_dirichlet(self, bcs: list[DirichletBCMagneticEdge]):
        """
        Applies Dirichlet boundary conditions to the specified edges.

        Parameters:
        -----------
        bcs: DirichletBCMagneticEdge
            boundary conditions

        Sets:
        -----------
        self._K, self._f, as well as the optional
        self._fixed_idx, self._free_idx, self._fixed_vals, self._K_reduced, self._f_reduced, self._use_reduced
        """
        if not self._assembled:
            self.assemble()

        fixed: dict[int, float] = {}

        for bc in bcs:
            vals = bc.values(self.mesh.nodes, self.mesh.edges)
            for e_idx, v in zip(bc.edges, vals):
                fixed[int(e_idx)] = float(v)
        self._fixed_idx = np.array(sorted(fixed.keys()), dtype=int)
        fixed_edges = np.array([self.mesh.edges[i] for i in self._fixed_idx], dtype=int)
        nodes_fixed_edges = np.array(self.mesh.nodes[fixed_edges], dtype=float)
        edges_vectors = nodes_fixed_edges[:, 1, :] - nodes_fixed_edges[:, 0, :]
        edge_lengths = np.linalg.norm(edges_vectors, axis=1)
        normalized_edge_vectors = edges_vectors / edge_lengths[:, np.newaxis]
        self._fixed_vals = np.array([fixed[i] for i in self._fixed_idx], dtype=float)
        all_idx = np.arange(self.N, dtype=int)  # N = number of edges (DOFs)
        self._free_idx = np.setdiff1d(all_idx, self._fixed_idx, assume_unique=True)

        K = self._K
        f = self._f
        I = self._fixed_idx
        F = self._free_idx
        g = self._fixed_vals

        if HAS_SCIPY and sp.issparse(K):
            K = K.tocsr()
            K_ff = K[F, :][:, F]
            K_fc = K[F, :][:, I]
            f_f = f[F] - K_fc @ g
        else:
            K_ff = K[np.ix_(F, F)]
            K_fc = K[np.ix_(F, I)]
            f_f = f[F] - K_fc @ g

        self._K_reduced = K_ff
        self._f_reduced = f_f
        self._use_reduced = True

    def apply_neumann(self, bcs):
        """
        Method for applying Neumann boundary conditions (magnetic field tangent to boundary). Uses the fact that the
        scalar product of the basis function associated each edge and the unit tangent vector to that edge is constant
        (1/L, where L is the length of the edge) along the edge and the products with the other tangents equal zero.

        When these boundary conditions are applied, the object receives additional attributes.

        Parameters:
        -----------
        self: Magnetic2D
        bcs: NeumannBCMagneticEdges

        Returns:
        -----------
        Nothing

        Sets:
        -----------
        self._K and self._f, as well as the optional
        _free_idx, _fixed_idx, _fixed_vals, _K_reduced, _f_reduced, _use_reduced
        """
        if not self._assembled:
            self.assemble()

        fixed = {}

        for bc in bcs:
            vals = bc.values(self.mesh.nodes, self.mesh.edges)
            for e_idx, v in zip(bc.edges, vals):
                fixed[int(e_idx)] = (float(v[0]), float(v[1]))

        self._fixed_idx = np.array(sorted(fixed.keys()), dtype=int)
        all_idx = np.arange(self.N, dtype=int) 
        self._free_idx = np.setdiff1d(all_idx, self._fixed_idx, assume_unique=True)

        # get end points of edges
        fixed_edges = np.array([self.mesh.edges[i] for i in self._fixed_idx], dtype=int)
        nodes_fixed_edges = np.array(self.mesh.nodes[fixed_edges], dtype=float)

        # calculate length of edges
        edge_vectors = nodes_fixed_edges[:, 1, :] - nodes_fixed_edges[:, 0, :]
        edge_lengths = np.linalg.norm(edge_vectors, axis=1)

        # calculate unit tangent vectors
        normalized_edge_vectors = edge_vectors / edge_lengths[:, np.newaxis]

        # set g via quadrature rule (midpoint)
        fixed_vals = np.array([fixed[i] for i in self._fixed_idx], dtype=float)
        self._fixed_vals = (0.5 * np.einsum('ij,ij->i', fixed_vals, normalized_edge_vectors)
                            / edge_lengths[:])
        K = self._K
        f = self._f
        I = self._fixed_idx
        F = self._free_idx
        g = self._fixed_vals

        if HAS_SCIPY and sp.issparse(K):
            K = K.tocsr()
            K_ff = K[F, :][:, F]
            K_fc = K[F, :][:, I]
            f_f = f[F] - K_fc @ g
        else:
            K_ff = K[np.ix_(F, F)]
            K_fc = K[np.ix_(F, I)]
            f_f = f[F] - K_fc @ g

        self._K_reduced = K_ff
        self._f_reduced = f_f
        self._use_reduced = True

    def solve(self) -> np.ndarray:
        """
        Solve the H(curl) magnetostatic problem and return the edge DOFs A_edge.

        Returns:
        -----------
        A_edge : np.ndarray
            The solution vector of size N = number of edges (one DOF per edge).
        """
        import numpy as np  # in case this file is used standalone

        if not self._assembled:
            self.assemble()

        # If Dirichlet BCs have produced a reduced system, solve that
        if getattr(self, "_use_reduced", False):
            K = self._K_reduced
            f = self._f_reduced

            if HAS_SCIPY and sp.issparse(K):
                u_free = spla.spsolve(K, f)
            else:
                u_free = np.linalg.solve(K, f)

            # Reconstruct full edge-DOF vector
            A_edge = np.zeros(self.N, dtype=float)
            A_edge[self._fixed_idx] = self._fixed_vals
            A_edge[self._free_idx] = u_free

            self.A_edge = A_edge
            return self.A_edge

        # No reduced system: solve the full one
        K_full, f_full = self._K, self._f
        if HAS_SCIPY and sp.issparse(K_full):
            self.A_edge = spla.spsolve(K_full, f_full)
        else:
            self.A_edge = np.linalg.solve(K_full, f_full)

        return self.A_edge

    def magnetic_field(self, quad=TriangleQuadrature()) -> tuple[np.ndarray, np.ndarray]:
        """
        Compute the magnetic flux density for the H(curl) formulation.

        In this 2D H(curl) setup with in-plane vector potential A(x,y),
        the magnetic flux density is out-of-plane:

            B_z = curl A = ∂_x A_y - ∂_y A_x

        For lowest-order Nédélec elements on triangles, curl(N_i) is
        constant per cell, so B_z is piecewise constant per element.

        Returns:
        -----------
        Bz_cells : (n_tris,) array
            Cell-centered B_z values (out-of-plane magnetic flux density).
        centers : (n_tris, 2) array
            Coordinates of the triangle centers (barycenters).
        """
        if self.A_edge is None or self.A_edge.size == 0:
            raise RuntimeError("Call solve() first.")

        fin_elem = self.fin_elem
        quad_pts = quad.points  # 1-point quadrature at centroid

        n_tris = self.mesh.tris.shape[0]
        Bz_cells = np.zeros(n_tris, dtype=float)
        centers = np.zeros((n_tris, 2), dtype=float)

        for cell_id, tri in enumerate(self.mesh.tris):
            # Physical geometry of this triangle
            cell_vertices = self.mesh.nodes[tri]  # (3,2)
            centers[cell_id] = cell_vertices.mean(axis=0)

            # Scalar curl of each local basis function on this cell
            curls = fin_elem.evaluate_curl(cell_vertices, quad_pts)  # (1, n_local_dofs)
            curl_local = curls[0, :]  # (3,) for lowest-order

            # Map global edge DOFs -> local DOFs on this cell, including orientation
            edge_dofs = self.mesh.tri_edges[cell_id]  # (3,)
            edge_signs = self.mesh.tri_edge_signs[cell_id]  # (3,)
            A_local = edge_signs * self.A_edge[edge_dofs]  # (3,)

            # B_z is constant on the cell: sum_i A_i^{(K)} curl(N_i)
            Bz_cells[cell_id] = np.dot(A_local, curl_local)

        return Bz_cells, centers
